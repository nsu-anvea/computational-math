# Отчет по численному интегрированию

## Цель работы
Реализовать методы численного интегрирования (левых, правых и средних прямоугольников, трапеций, Симпсона) и исследовать их порядки точности с помощью метода Рунге.

---

## Часть 1. Численное интегрирование различных функций

### 1.1. Функция f(x) = -7.23x - 15, пределы [-12, -9]

| Метод | n=10 | n=20 | n=50 | n=100 | n=1000 |
|-------|------|------|------|-------|--------|
| Левые прямоугольники | 185.9985 | 184.3717 | 183.3957 | 183.0703 | 182.7775 |
| Правые прямоугольники | 179.4915 | 181.1183 | 182.0943 | 182.4197 | 182.7125 |
| Средние прямоугольники | 182.7450 | 182.7450 | 182.7450 | 182.7450 | 182.7450 |
| Трапеции | 182.7450 | 182.7450 | 182.7450 | 182.7450 | 182.7450 |
| Симпсон | 182.7450 | 182.7450 | 182.7450 | 182.7450 | 182.7450 |

**Вывод:** Для линейной функции методы средних прямоугольников, трапеций и Симпсона дают точный результат даже при малых n.

---

### 1.2. Функция f(x) = 1.6x¹³ - 5x⁸ - 102x² + 23, пределы [5, 9]

| Метод | n=10 | n=20 | n=50 | n=100 | n=1000 |
|-------|------|------|------|-------|--------|
| Левые прямоугольники | 1878533972995.522 | 2226639996093.834 | 2454115829387.831 | 2533065009506.695 | 2605457040517.901 |
| Правые прямоугольники | 3504461538649.282 | 3039603778920.714 | 2779301342518.583 | 2695657766072.071 | 2621716316174.439 |
| Средние прямоугольники | 2574746019192.146 | 2603815280125.912 | 2612014189625.559 | 2613187597821.452 | 2613574939816.455 |
| Трапеции | 2691497755822.402 | 2633121887507.273 | 2616708585953.207 | 2614361387789.383 | 2613586678346.169 |
| Симпсон | 2614908333067.673 | 2613663264735.565 | 2613581023170.573 | 2613578988401.442 | 2613578852672.424 |

**Вывод:** Для полинома высокой степени метод Симпсона сходится значительно быстрее остальных методов.

---

### 1.3. Функция f(x) = √(10x - 1), пределы [1, 2]

| Метод | n=10 | n=20 | n=50 | n=100 | n=1000 |
|-------|------|------|------|-------|--------|
| Левые прямоугольники | 3.6528942387 | 3.6871912854 | 3.7076656864 | 3.7144731706 | 3.7205925024 |
| Правые прямоугольники | 3.7887841330 | 3.7551362326 | 3.7348436653 | 3.7280621600 | 3.7219514013 |
| Средние прямоугольники | 3.7214883321 | 3.7213261090 | 3.7212806547 | 3.7212741601 | 3.7212720168 |
| Трапеции | 3.7208391859 | 3.7211637590 | 3.7212546758 | 3.7212676653 | 3.7212719519 |
| Симпсон | 3.7212712805 | 3.7212719500 | 3.7212719940 | 3.7212719951 | 3.7212719952 |

**Вывод:** Все методы сходятся к значению ≈ 3.7212719952, метод Симпсона достигает высокой точности уже при n=50.

---

### 1.4. Функция f(x) = 519/(41x + 1)³, пределы [0, 3]

| Метод | n=10 | n=20 | n=50 | n=100 | n=1000 |
|-------|------|------|------|-------|--------|
| Левые прямоугольники | 155.7811 | 78.1185 | 32.1618 | 17.7224 | 7.1550 |
| Правые прямоугольники | 0.0811 | 0.2685 | 1.0218 | 2.1524 | 5.5980 |
| Средние прямоугольники | 0.4559 | 1.2569 | 3.2830 | 4.8851 | 6.3051 |
| Трапеции | 77.9311 | 39.1935 | 16.5918 | 9.9374 | 6.3765 |
| Симпсон | 52.0008 | 26.2810 | 11.6147 | 7.7192 | 6.3298 |

**Вывод:** Функция имеет особенность в знаменателе, методы медленно сходятся. Разница между левыми и правыми прямоугольниками очень велика.

---

### 1.5. Функция f(x) = ln(x⁵ + 12), пределы [3, 5]

| Метод | n=10 | n=20 | n=50 | n=100 | n=1000 |
|-------|------|------|------|-------|--------|
| Левые прямоугольники | 13.5356571 | 13.6626252 | 13.7383324 | 13.7634892 | 13.7860966 |
| Правые прямоугольники | 14.0376088 | 13.9136011 | 13.8387228 | 13.8136844 | 13.7911161 |
| Средние прямоугольники | 13.7895934 | 13.7888532 | 13.7886460 | 13.7886164 | 13.7886066 |
| Трапеции | 13.7866329 | 13.7881132 | 13.7885276 | 13.7885868 | 13.7886063 |
| Симпсон | 13.7886068 | 13.7886066 | 13.7886065 | 13.7886065 | 13.7886065 |

**Вывод:** Метод Симпсона дает стабильный результат ≈ 13.7886065 уже при n=10.

---

### 1.6. Функция f(x) = sin(2π/3·x² - 9π/5·x + 14.7), пределы [-28π/11, 7π]

| Метод | n=10 | n=20 | n=50 | n=100 | n=1000 |
|-------|------|------|------|-------|--------|
| Левые прямоугольники | 0.8802 | 0.1426 | 0.3593 | 0.1199 | -0.9684 |
| Правые прямоугольники | 0.2755 | -0.1597 | 0.2383 | 0.0594 | -0.9744 |
| Средние прямоугольники | -0.5950 | 0.4060 | -0.1195 | -2.0027 | -0.9742 |
| Трапеции | 0.5778 | -0.0086 | 0.2988 | 0.0897 | -0.9714 |
| Симпсон | 1.0339 | -0.2041 | 2.2283 | 0.0200 | -0.9733 |

**Вывод:** Быстроосциллирующая функция требует большого количества разбиений. Значения при малых n сильно различаются, сходимость к ≈ -0.973 наблюдается только при n=1000.

---

### 1.7. Функция f(x) = 1/(1 + eˣ), пределы [0, 1]

| Метод | n=10 | n=20 | n=50 | n=100 | n=1000 |
|-------|------|------|------|-------|--------|
| Левые прямоугольники | 0.3914829245 | 0.3856730808 | 0.3821978585 | 0.3810412308 | 0.3800010268 |
| Правые прямоугольники | 0.3683770666 | 0.3741201519 | 0.3775766869 | 0.3787306451 | 0.3797699682 |
| Средние прямоугольники | 0.3798632371 | 0.3798799311 | 0.3798846032 | 0.3798852706 | 0.3798854908 |
| Трапеции | 0.3799299956 | 0.3798966163 | 0.3798872727 | 0.3798859379 | 0.3798854975 |
| Симпсон | 0.3798854430 | 0.3798854899 | 0.3798854930 | 0.3798854930 | 0.3798854930 |

**Вывод:** Все методы сходятся к значению ≈ 0.3798854930.

---

## Часть 2. Анализ порядков точности методов (метод Рунге)

### 2.1. Функция f(x) = -x²² + 258x¹¹ - 1.85x⁵ + 2025, пределы [-2, 1]

| Метод | I(n=100) | I(n=200) | I(n=400) | Порядок p | Теор. p | Уточн. значение |
|-------|----------|----------|----------|-----------|---------|-----------------|
| Левые прямоугольники | -521185.989 | -483010.999 | -464610.876 | **1.053** | 1 | -447489.924 |
| Правые прямоугольники | -379499.471 | -412167.740 | -429189.246 | **0.941** | 1 | -447706.282 |
| Средние прямоугольники | -444836.010 | -446210.753 | -446555.286 | **1.996** | 2 | -446670.508 |
| Трапеции | -450342.730 | -447589.370 | -446900.061 | **1.998** | 2 | -446669.860 |
| Симпсон | -446692.100 | -446671.583 | -446670.292 | **3.990** | 4 | -446670.205 |

**Анализ:** 
- Экспериментальные порядки точности соответствуют теоретическим
- Левые/правые прямоугольники: p ≈ 1
- Средние прямоугольники и трапеции: p ≈ 2
- Симпсон: p ≈ 4
- Метод Симпсона имеет наименьшую погрешность (≈ 0.087)

---

### 2.2. Функция f(x) = tg(π/8·x)·cos(19π/4·x - 3), пределы [-3π/7, 11π/2]

| Метод | I(n=100) | I(n=200) | I(n=400) | Порядок p | Теор. p |
|-------|----------|----------|----------|-----------|---------|
| Левые прямоугольники | -7.909 | 9.772 | -13.745 | **-0.412** | 1 |
| Правые прямоугольники | -8.053 | 9.700 | -13.781 | **-0.403** | 1 |
| Средние прямоугольники | 27.453 | -37.262 | 25.320 | **0.048** | 2 |
| Трапеции | -7.981 | 9.736 | -13.763 | **-0.407** | 2 |
| Симпсон | -8.214 | 15.642 | -21.596 | **-0.642** | 4 |

**Анализ:**
- Функция сильно осциллирует, методы не сходятся на выбранных сетках
- Отрицательные порядки точности указывают на недостаточное количество разбиений
- Необходимо значительно увеличить n для корректной оценки
- Это типичный случай, когда стандартные квадратурные формулы плохо работают для быстроосциллирующих функций

---

## Структура проекта и сборка

### Makefile для компиляции проекта

Для автоматизации сборки проекта был создан Makefile:

```makefile
CC = gcc
LDFLAGS = -lm

SRC_DIR = src
BLD_DIR = build

TARGET = calcint

define compile
$(CC) $< -o $(BLD_DIR)/$(1) $(LDFLAGS)
endef

all: $(TARGET) runge

$(TARGET): $(SRC_DIR)/main.c | $(BLD_DIR)
	$(call compile,$(TARGET))

runge: $(SRC_DIR)/runge.c | $(BLD_DIR)
	$(call compile,$@)

$(BLD_DIR):
	mkdir -p $@

clean:
	rm -rf $(BLD_DIR)

.PHONY: all build clean
```

**Описание Makefile:**

- **CC** - компилятор (gcc)
- **LDFLAGS** - флаги линковки (-lm для математической библиотеки)
- **SRC_DIR** - директория с исходными кодами (src/)
- **BLD_DIR** - директория для скомпилированных файлов (build/)
- **TARGET** - имя основной программы (calcint)

**Функция compile:**
- Определяет шаблон компиляции для всех целей
- Принимает имя выходного файла как параметр
- Автоматически добавляет флаги линковки

**Цели сборки:**
- `make all` или `make` - собирает обе программы (calcint и runge)
- `make calcint` - собирает только основную программу
- `make runge` - собирает только программу анализа порядков
- `make clean` - удаляет директорию build с скомпилированными файлами

**Особенности:**
- Автоматическое создание директории build при необходимости
- Использование макроса для избежания дублирования кода компиляции
- Зависимость от существования директории build (| $(BLD_DIR))

**Использование:**
```bash
# Сборка всего проекта
make all

# Запуск программ
./build/calcint
./build/runge

# Очистка
make clean
```

---

## Значимые части кода

### Реализация методов интегрирования

#### Метод левых прямоугольников
```c
double left_rectangles(double (*f)(double), double a, double b, int n) {
    double h = (b - a) / n;
    double sum = 0.0;
    
    for (int i = 0; i < n; i++) {
        double x = a + i * h;
        sum += f(x);
    }
    
    return sum * h;
}
```

#### Метод правых прямоугольников
```c
double right_rectangles(double (*f)(double), double a, double b, int n) {
    double h = (b - a) / n;
    double sum = 0.0;
    
    for (int i = 1; i <= n; i++) {
        double x = a + i * h;
        sum += f(x);
    }
    
    return sum * h;
}
```

#### Метод средних прямоугольников
```c
double middle_rectangles(double (*f)(double), double a, double b, int n) {
    double h = (b - a) / n;
    double sum = 0.0;
    
    for (int i = 0; i < n; i++) {
        double x = a + (i + 0.5) * h;
        sum += f(x);
    }
    
    return sum * h;
}
```

#### Метод трапеций
```c
double trapezoid(double (*f)(double), double a, double b, int n) {
    double h = (b - a) / n;
    double sum = (f(a) + f(b)) / 2.0;
    
    for (int i = 1; i < n; i++) {
        double x = a + i * h;
        sum += f(x);
    }
    
    return sum * h;
}
```

#### Метод Симпсона
```c
double simpson(double (*f)(double), double a, double b, int n) {
    // Для метода Симпсона n должно быть четным
    if (n % 2 != 0) n++;
    
    double h = (b - a) / n;
    double sum = f(a) + f(b);
    
    for (int i = 1; i < n; i++) {
        double x = a + i * h;
        if (i % 2 == 0) {
            sum += 2 * f(x);
        } else {
            sum += 4 * f(x);
        }
    }
    
    return sum * h / 3.0;
}
```

### Вычисление порядка точности по методу Рунге

```c
double runge_order(double I_n, double I_2n, double I_4n) {
    // p = log₂(|I_n - I_{2n}| / |I_{2n} - I_{4n}|)
    double numerator = fabs(I_n - I_2n);
    double denominator = fabs(I_2n - I_4n);
    
    if (denominator < 1e-15) {
        return 0.0;
    }
    
    return log2(numerator / denominator);
}
```

### Уточнение значения интеграла
```c
double runge_refined(double I_2n, double I_4n, double p) {
    // I_уточн = I_{4n} + (I_{4n} - I_{2n}) / (2^p - 1)
    return I_4n + (I_4n - I_2n) / (pow(2, p) - 1);
}
```

---

## Выводы

1. **Метод Симпсона** показал наилучшую точность для гладких функций, достигая порядка p ≈ 4
2. **Методы средних прямоугольников и трапеций** имеют порядок p ≈ 2 и дают хорошие результаты
3. **Методы левых и правых прямоугольников** имеют порядок p ≈ 1 и наименее точны
4. Для **быстроосциллирующих функций** требуется значительно большее количество разбиений
5. Метод Рунге успешно подтверждает теоретические порядки точности на гладких функциях
6. При наличии особенностей (функция 1.4) все методы сходятся медленнее